<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id ="box"></div>
    <div id="btns" style="width:1000px;margin:20px"></div>
    <script>
    // 1,js中哪些会被隐士转换成false
       //undefined null '' NaN  false 0
  
    // 2,用定时器写一个时钟
        // var box = document.getElementById('box');
        // var timer;
        // function fn(){
        //     var myDate = new Date();
        //     var FullYear = myDate.getFullYear();
        //     var Month = num(myDate.getMonth()+1);
        //     var Dates = num(myDate.getDate());
        //     var H = num(myDate.getHours())
        //     var M = num(myDate.getMinutes());
        //     var s = num(myDate.getSeconds());
        //     let html =`${FullYear}-${Month}-${Dates} ${H}:${M}:${s}`;
        //     //补零
        //     function num(n){
        //         return n = n<10?'0'+n:n;
        //     }
        
        // box.innerHTML = html;
            
        // }
        // fn();
        // timer = setInterval(fn, 1000) //每一秒执行一次

    // 3，使用Object.assign,Object.keys,Object.values展示他们的用法
        //Object.assign用法（拼接对象,返回一个新的对象）
        // let obj1 = {a:1};
        // let obj2 = {b:2};
        // let obj3 = {c:3};
        // let obj = Object.assign({},obj1,obj2,obj3);
        // console.log(obj)

        /*let persons = {
            name:"张三",
            age:25,
            address:"深圳",
            getName:function(){},
            arr:['1','2','3']
        };
        console.log(Object.keys(persons)); //["name", "age", "address", "getName"] 获取对象中key值
        console.log(Object.values(persons)) //["张三", 25, "深圳", ƒ]  获取对象中values值
        console.log(persons.arr[1])

        for(let key of Object.keys(persons)){
            console.log(key);
            //name age address getName
        }
        for(let value of Object.values(persons)){
            console.log(value)
            //张三 25 深圳 f(){}
        }

        let obj = {a:1,b:2,c:3};
        console.log(Object.entries(obj)) //[['a':1], ['b':2],['c':3]]
        for(let [key,value] of Object.entries(obj)){
        console.log(key,value);
        //a,1
        //b,2
        //c,3
        } */
    // 4，什么是防抖和节流，并写出一个防抖函数和一个节流函数
        //触发高频函数事件后，n秒内函数只能执行一次，如果在n秒内这个事件再次被触发的话，那么会重新计算时间
        //高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率


    // 5，如何给1万个button按钮添加绑定事件
    function bindEvent() {
            var btns = document.getElementById('btns');
            for (var i = 0; i < 10000; i++) {
                var btn = document.createElement('button');
                btn.innerHTML = "按钮" + i;
                btns.appendChild(btn);
            }
            btns.addEventListener('click', function (e) {
                var e = e || window.event;
                var target = e.target || e.srcElement;
                if (target.tagName == 'BUTTON') {
                    alert(target.innerHTML);
                }
            }, false)
        }
        bindEvent()
    // 6，点和[]的用法，有什么区别
        （1）.与[]都可以用于获取对象属性，但是写法不同.后面直接跟属性，[]中的属性需要以字符串的形式传入。
            设置obj的宽度为300px。
            .的书写方式：
            obj.style.width='300px';
            []的书写方式：
            obj.style['width']='300px';
        (2).不能传入变量，而[]可以传入变量。
    // 7，使用递归手写一个快速排序

    // 8，new操作符具体干了什么呢？


        // var obj = new Object(); //  创建一个空对象
        // obj._proto_ = Func.prototype; //让这个对象的隐士原型指向函数的原型链
        // var result = Func.call(obj); //this指向obj对象   并执行函体
        // // return typeof result === 'object'? result : obj; //判断函数体返回值类型

        function person (name, age, sex){
            console.log(name, age, sex)
			this.name = name
			this.age = age
			this.sex = sex
	    }
        function newFoo(fn) {
            console.log(fn)
            // 第一步：创建一个新对象
            var obj = {}
            // 新对象继承Person.prototype
            obj.__proto__ = fn.prototype 
            return function () {
                // 使用指定的参数调用构造函数 Person ，并将 this 绑定到新创建的对象
                fn.apply(obj,arguments)
                    console.log(obj) //person {name: "男", age: 30, sex: "75kg"}
                    return obj;
                }
        }
        var person2 = newFoo (person)('男', 30, '75kg')
        console.log(person2.__proto__ == person.prototype) //true





    // 9，说一下什么是原型和原型链
    //     在js的所有函数对象中，都存在一个属性prototype，该属性对应当前对象的原型。
    //     所有的对象都存在一个_proto_属性， _proto_属性指向实例对象的构造函数的原型。

    //     在查找一个对象的属性时，我们在当前对象找不到该属性，则会沿着原型链一直往上查找，直到找到为止，
    //     如果到了原型顶端，还没找着，则返回unll

    // 10，继承的几种方式
    //     1）构造函数继承
    //     2）原型继承
    //     3）原型继承+构造函数
    //     4）原型式继承
    </script>
</body>
</html>